#!/bin/python
"""
Initialise and download image data from Google Earth Engine. Restricted to
Sentinel and Landsat images only:

- Sentinel-1 SAR GRD: C-band Synthetic Aperture Radar
- Sentinel-2 MSI: Multispectral Instrument
- Landsat 4 TM Thematic Mapper 1982-1993
- Landsat 5 TM Thematic Mapper 1984-2012
- Landsat 7 ETM+ Enhanced Thematic Mapper Plus (ETM+) 1999-2021
- Landsat 8 OLI/TIRS Operational Land Imager (OLI) and Thermal Infrared Sensor 
  (TIRS) 2013-Now 
- Landsat 9 OLI-2/TIRS-2 Operational Land Imager (OLI) and
  Thermal Infrared Sensor (TIRS) 2021-Now

For more information on these data sources, browse the Google Earth Engine Data
Catalog: https://developers.google.com/earth-engine/datasets

MAX FILE DOWNLOAD SIZE LIMIT: 50331648 bytes (~ 50 MB)

---
Functions:

initialise() - Initialise Data-Harvester for Google Earth Engine
preprocess() - Select, filter, scale, offset, compute cloud masking and compute
               spectral indices that can be reduced into a single image
               composite
preview() - Select available bands and visualise using geemap, an interactive
            maps widget
 
download_thumbnail()
download_raster()
download_data()

---

Copyright 2022 Sydney Informatics Hub (SIH), The University of Sydney This
open-source software is released under the LGPL-3.0 License

"""
import ee
import eemont  # trunk-ignore(flake8/F401)
import geemap.foliumap as geemap
import geemap.colormaps as cm
import subprocess
import requests
import tempfile
from alive_progress import alive_bar
from alive_progress import config_handler
from termcolor import colored
import os

# import geedim as gd
# import logging
# from IPython.display import Image


# Landsat collections for now (while testing)
collections = {
    "satellites": {
        "LANDSAT/LC09/C02/T2_L2": "Landsat 9 Surface Reflectance",
        "LANDSAT/LC09/C02/T2": "Landsat 9 raw radiance",
        "LANDSAT/LC08/C02/T2_L2": "Landsat 8 Surface Reflectance",
        "LANDSAT/LC08/C02/T2": "Landsat 8 raw radiance",
        "LANDSAT/LE07/C02/T2_L2": "Landsat 7 Surface Reflectance",
        "LANDSAT/LE07/C02/T2": "Landsat 7 raw radiance",
        "LANDSAT/LT05/C02/T2_L2": "Landsat 5 Surface Reflectance",
        "LANDSAT/LT05/C02/T2": "Landsat 5 Raw Radiance",
        "COPERNICUS/S2_SR": "Sentinel-2 Surface Reflectance",
    }
}

# Progress bar config
config_handler.set_global(
    force_tty=True,
    bar=None,
    spinner="waves",
    monitor=False,
    stats=False,
    receipt=True,
    elapsed="{elapsed}",
)

# ==============================================================================
def initialise():
    """Initialise Google Earth Engine API

    This is an internal function. The function will try to initialise Google
    Earth Engine API. If it fails, the user is recommended to authenticate
    through the command line interface.
    """

    # Check if initialised:
    try:
        if not ee.data._credentials:
            with alive_bar(
                total=1, title=colored("\u2139 Initialising Earth Engine...", "blue")
            ) as bar:
                ee.Initialize()
                bar(1)
        else:
            print(colored("\u2139 Initialising Earth Engine...", "blue"))
            print(colored("✔ Earth Engine API already authenticated", "green"))
            return
        print(colored("✔ Earth Engine authenticated", "green"))
    # If error pops up, it is likely that user has not performed Earth Engine
    # authentication in CLI. Prompt them to do so (faster than Python
    # ee.Authenticate)
    except ee.EEException:
        print(
            colored(
                "\u2139 Unable to authorise access to your Google Earth Engine account",
                "red",
            )
        )
        print("Running `earthengine authenticate`...")
        bashCommand = "earthengine authenticate"
        subprocess.run(bashCommand, shell=True)


# ==============================================================================
def preprocess(
    collection,
    bbox,
    date,
    endDate,
    mask_clouds=True,
    reduce="median",
    clip=True,
    spectral="NDVI",
):
    """Preprocess a GEE ImageCollection

    Obtain image stacks from a Google Earth Engine catalog collection for
    processing. Supports Sentinel-2, Landsat 4-8 and all their bands. The
    resulting ImageCollection object is then preprocessed in Earth Engine.
    Server-side cloud masking, scaling and offsetting are all supported. Data
    may also be composited into a single image representing, for example, the
    median, min, max, mean or standard deviation of the images.

    Args:
        collection (str): ImageCollection ID
        bbox (list): Bounding box
        date (str): Either YYYY, YYYY-MM or YYYY-MM-DD
        endDate (str): Either YYYY, YYYY-MM or YYYY-MM-DD
        mask_clouds (bool, optional): Apply cloud masking. Defaults to True
        reduceBy (str, optional): Apply compositioning into single image
        Defaults to "median"
        clip (bool, optional):Clip image to area of interest. Defaults to True
        spectral (str, optional): compute a spectral index from Awesome Spectral
        Indices: https://awesome-ee-spectral-indices.readthedocs.io/en/latest/

    Returns:
        ee.Image: An Earth Engine ee.Image object
    """
    if not isinstance(spectral, str):
        raise Exception("Argument `spectral` can only contain one index")

    with alive_bar(
        total=1,
        title=colored("\u2139 Filtering images from Earth Engine...", "blue"),
    ) as bar:
        aoi = ee.Geometry.Rectangle(bbox)
        ee_image = (
            ee.ImageCollection(collection).filterDate(date, endDate).filterBounds(aoi)
        )
        bar(1)
    # Try to scale and offset the image collection
    try:
        ee_image = ee_image.scaleAndOffset()
    except Exception:
        pass

    # Mask clouds (default True)
    if mask_clouds:
        with alive_bar(
            total=1,
            title=colored("\u2139 Masking clouds...", "blue"),
        ) as bar:
            ee_image = ee_image.maskClouds()
            bar(1)
    # Generate spectral index
    ee_image = ee_image.spectralIndices(spectral, online=True)
    # Aggregate
    aggList = ["median", "mean", "sum", "mode", "max", "min", "mosaic"]
    if reduce in aggList:
        with alive_bar(
            total=1,
            title=colored(f"\u2139 Reducing image pixels by {reduce}...", "blue"),
        ) as bar:
            func = getattr(ee_image, reduce)
            ee_image = func()
            bar(1)
    else:
        print("✘ | Unrecognised `reduceBy` string. Processing halted")
        print(
            "`reduceBy` must be one of 'median', 'mean', 'sum', 'mode', 'max',",
            " 'min' or 'mosaic'",
        )
        return
    if clip:
        ee_image = ee_image.clip(aoi)

    print(colored("✔ Image preprocessing complete", "green"))
    return ee_image


# ==============================================================================
def select_bands(ee_image, bands=None):
    # If no bands are provided, print a list of available bands and stop
    with alive_bar(
        total=1, title=colored("\u2139 Validating band(s)...", "blue")
    ) as bar:
        availBands = ee_image.bandNames().getInfo()
        bar(1)
    if bands is None:
        print("✘ No bands defined - nothing to preview")
        print("\u2139 Please select one or more bands to view image:")
        print(availBands)
        return
    else:
        # Select bands
        ee_image = ee_image.select(bands)
    return ee_image


# =============================================================================


def preview(
    ee_image,
    bands=None,
    minmax="auto",
    scale=100,
    palette=None,
    save_to=None,
):
    """Interactive map to visualise GEE image
    Args:
        image: any ee.Image object that has bands
        bands (list): Band(s) to visualise, as a string or list. If set to None,
            will not generate a map but will print a list of available bands.
            Defaults to None
        minmax (str or list, optional): Either stretch automatically by 3
        standard deviations, or present a list of 2 integer values to specify
        minimum and maximum values.
        scale (int, optional): Scale. The bigger the value, the faster the
        preview. Defaults to 100
        palette (list, optional): list of hex colour codes to use as palette for
        images containing a single band. Also available: cm.palettes.ndwi,
        cm.palettes.dem  and (by default if set to None) cm.palettes.ndvi

    Returns:
        Map: An interactive geemap
    """
    coordinates = ee_image.geometry().getInfo()["coordinates"]
    aoi = ee.Geometry.Polygon(coordinates)

    # If no bands are provided, print a list of available bands and stop
    with alive_bar(
        total=1, title=colored("\u2139 Validating band(s)...", "blue")
    ) as bar:
        availBands = ee_image.bandNames().getInfo()
        bar(1)
    if bands is None:
        print("✘ No bands defined - nothing to preview")
        print("\u2139 Please select one or more bands to view image:")
        print(availBands)
        return
    else:
        # Select bands
        ee_image = ee_image.select(bands)
        # Convert bands to list if string
        bands = [bands] if isinstance(bands, str) else bands
        # Auto stretch min and max values for better preview
        if minmax == "auto":
            with alive_bar(
                total=1,
                title=colored(
                    "\u2139 Detecting band min and max parameters for visualisation...",
                    "blue",
                ),
            ) as bar:
                minmax = stretch_minmax(ee_image, aoi, bands, 3, scale)
                bar(1)

        # Add more info to visualisation parameter
        param = {
            "min": minmax[0],
            "max": minmax[1],
        }
        with alive_bar(
            total=1,
            title=colored(
                "\u2139 Plotting...",
                "blue",
            ),
        ) as bar:
            Map = geemap.Map()
            Map.centerObject(aoi, 12)
            # If only 1 band is selected, check if NDVI or NDWI and use appropriate
            # palette. Otherwise, stick to default NDVI palette (TODO: viridis)
            if len(bands) == 1:
                # Palette
                if palette is None:
                    if "ndvi" in str(bands).lower():
                        palette = cm.palettes.ndvi
                    elif "ndwi" in str(bands).lower():
                        palette = cm.palettes.ndwi
                    else:
                        palette = cm.palettes.ndvi

                # Add palette to visualisation parameters
                param.update({"palette": palette})

                # Generate map layer
                Map.addLayer(ee_image, param, name=bands[0])
                #  Legend
                paramvis = {
                    k: param[k] for k in param.keys() & {"palette", "max", "min"}
                }
                Map.add_colorbar_branca(paramvis, label=bands[0], transparent_bg=False)
            else:
                Map.addLayer(ee_image, param, name=str(bands).strip("[]"))
            bar(1)
            # Save map html to temp directory
            if save_to is not None:
                # Prone to abuse, needs validation in future
                Map.to_html(save_to)
        return Map


# =============================================================================
def download(ee_image, filename, Map=None, region=None, crs=None, scale=None):
    geemap.download_ee_image(ee_image, filename, region, crs, scale)


# =============================================================================
def stretch_minmax(ee_image, region, bands, sd=3, scale=None):
    """Use standard deviation to generate minimum and maxmimum values for
    Earth Engine image band(s).

    Args:
        image: An ee.Image object
        region (dict): Geometry parameters from ee.Image.Geometry()
        bands (str or list): Specify the band(s) of interest
        std (int, optional): Standard deviations to calculate from the mean.
        Defaults to 3.
        scale (int, optional): Scale. Defaults to None.

    Returns:
        dict: A dictionary containing min and max values
    """

    # Create dictionary
    geom = region or ee_image.geometry()
    params = dict(geometry=geom, bestEffort=True)

    # Set scale if available
    if scale:
        params["scale"] = scale
    params["reducer"] = ee.Reducer.mean()
    mean = ee_image.reduceRegion(**params)

    params["reducer"] = ee.Reducer.stdDev()
    stdDev = ee_image.reduceRegion(**params)

    def min_max(band, val):
        minv = ee.Number(val).subtract(ee.Number(stdDev.get(band)).multiply(sd))
        maxv = ee.Number(val).add(ee.Number(stdDev.get(band)).multiply(sd))
        return ee.List([minv, maxv])

    # Make calculations based on no. of bands used
    if len(bands) == 1:
        band = bands[0]
        values = min_max(band, mean.get(band)).getInfo()
        minv = values[0]
        maxv = values[1]
    else:
        values = mean.map(min_max).select(bands).getInfo()
        minv = [values[bands[0]][0], values[bands[1]][0], values[bands[2]][0]]
        maxv = [values[bands[0]][1], values[bands[1]][1], values[bands[2]][1]]

    return [minv, maxv]


# =============================================================================
def add_date(image):
    img_date = ee.Date(image.date())
    img_date = ee.Number.parse(img_date.format("YYYYMMdd"))
    return image.addBands(ee.Image(img_date).rename("date").toInt())


# =============================================================================
# NOT USED YET (but validation code will be reused)
# focus on landsat 8 for now
# This looks interesting:
# https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC08_C01_T1_32DAY_NDVI
# This too:
# https://www.gis-tutorials.net/earth-engine/how-to-calculate-ndvi-from-landsat-4578-and-sentinel-2-imagery-in-google-earth-engine/
def get_landsat(layers, bbox):
    # Define available Landsat ee layers (via online catalog)
    # Note: list is restricted to T2 surface reflectance and raw at-sensor radiance

    # If single item, convert to list
    layers = [layers] if isinstance(layers, str) else layers

    # Stop function if a layer is not recognised
    if not set(layers).issubset(landsat["collections"]):
        print("▲ | Cannot recognise one or more layers")
        return
    else:
        print("\u2139 Downloading the following Landsat layer(s) and properties:")
        print(
            " ",
            "\n  ".join(
                map(str, [v for k, v in landsat["collections"].items() if k in layers])
            ),
        )
    print(f"  Area of interest: {bbox}")


# =============================================================================
def download_image(
    collection_name,
    bbox,
    startDate,
    endDate,
    outpath,
    res=1.0,
    ag="median",
    bands=None,
    format_out="GEO_TIFF",
):
    """
    Computes median of ImageCollection of all images between startDate and endDate
    and downloads image to output path.

    Maximum download size is 32 MB, maximum grid dimension is 10000

    TBD:
    - add cloud-cover mask

    Args:
    -----
    collection_name : str, GEE ImageCollection name
    bbox : list, bounding box
    startDate : str, YYYY-MM-DD
    endDate : str, YYYY-MM-DD
    outpath : str, output path
    res : float, resolution in arcsec
    ag : str, agregation function: 'median' (default), 'mean', 'sum', 'mode', 'max', 'min', 'mosaic'
    bands : list of bands, e.g. ['B3', 'B8', 'B11'], if None it assumes Singleband
    format_out : str, 'GEO_TIFF' (default), or 'ZIPPED_GEO_TIFF'

    Return
    ------
    filename out : str
    """

    # Check  first if outpath exists:
    if not os.path.exists(outpath):
        raise Exception(f"Output path {outpath} does not exist.")

    # generate output name:
    if format_out == "GEO_TIFF":
        fname_end = ".tif"
    elif format_out == "ZIPPED_GEO_TIFF":
        fname_end = ".zip"
    fname_out = os.path.join(
        outpath, "img_" + ag + "_" + startDate + "_" + endDate + fname_end
    )

    # getgrid dimension
    width = abs(bbox[2] - bbox[0])
    height = abs(bbox[3] - bbox[1])
    nwidth = int(width / res * 3600)
    nheight = int(height / res * 3600)
    if (nwidth > 10000) | (nheight > 10000):
        raise Exception("Image is too large to download. Max grid dimension is 10000.")

    aoi = ee.Geometry.Rectangle(bbox)
    region = ee.Geometry.BBox(bbox[0], bbox[1], bbox[2], bbox[3])

    # Generate Image specs:
    # TBD could add cloud-cover mask
    img = (
        ee.ImageCollection(collection_name)
        .filterDate(startDate, endDate)
        .filterBounds(aoi)
    )

    # Return averaging of image collection
    if ag == "median":
        img_ag = img.median()
    elif ag == "mean":
        img_ag = img.mean()
    elif ag == "sum":
        img_ag = img.sum()
    elif ag == "mode":
        img_ag = img.mode()
    elif ag == "max":
        img_ag = img.max()
    elif ag == "min":
        img_ag = img.min()
    elif ag == "mosaic":
        img_ag = img.mosaic()
    else:
        raise Exception(f"Unknown aggregation function {ag}.")

    # img_info = img_ag.getInfo()

    # alternative provide "dimensions:" instead of scale
    if (bands is None) | (bands == "None"):
        url = img_ag.getDownloadUrl(
            {
                "region": region,
                #'scale': scale,
                "dimensions": (nwidth, nheight),
                "format": format_out,
            }
        )
    else:
        url = img_ag.getDownloadUrl(
            {
                "bands": bands,
                "region": region,
                #'scale': scale,
                "dimensions": (nwidth, nheight),
                "format": format_out,
            }
        )

    # get image
    response = requests.get(url)
    if response.ok:
        with open(fname_out, "wb") as fd:
            fd.write(response.content)
        print("Download successful,image saved: ", fname_out)
    else:
        print("Error: {}".format(response.status_code))
        print(response.text)
        raise Exception("Download failed")
    return fname_out


# TEST ------------------------------------------------------------------------
def test_download_image():
    """
    Test download_image function
    """
    # Test download_image function:
    # Download Landsat 8 image:
    # Landsat 8 collection:
    collection_name = "COPERNICUS/S2"
    # Landsat 8 bounding box:
    bbox = (149.769345, -30.335861, 149.949173, -30.206271)
    # Landsat 8 start date:
    startDate = "2017-01-01"
    # Landsat 8 end date:
    endDate = "2017-07-01"
    # Resolution:
    res = 1.0
    # Aggregation function:
    ag = "mosaic"
    # Bands:
    bands = ["B8", "B4"]
    # Format:
    format_out = "GEO_TIFF"
    # Output path:
    outpath = "./test_download_image"
    # make test directory
    os.makedirs(outpath, exist_ok=True)

    # Download image:
    fname_out1 = download_image(
        collection_name,
        bbox,
        startDate,
        endDate,
        outpath,
        res=res,
        ag=ag,
        bands=bands,
        format_out=format_out,
    )

    # Test single band image:
    collection_name = "LANDSAT/LC08/C01/T1_32DAY_NDVI"
    startDate = "2021-01-01"
    # Landsat 8 end date:
    endDate = "2022-01-01"
    # Output path:
    outpath = "../test_download_image"
    # Resolution:
    res = 1.0
    # Aggregation function:
    ag = "median"
    # Bands:
    bands = None
    # Download image:
    fname_out2 = download_image(
        collection_name, bbox, startDate, endDate, outpath, res=res, ag=ag
    )

    # Check that files are downloaded and not empty (> 100KB)
    file_size1 = os.path.getsize(fname_out1)
    assert file_size1 > 10000
    file_size2 = os.path.getsize(fname_out2)
    assert file_size2 > 10000

    print("Test download_image successful.")
